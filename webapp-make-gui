#!/usr/bin/env python3
"""GTK4/Libadwaita GUI for webapp-make - Web App Manager"""

__version__ = "1.0.0"

import gi
gi.require_version('Gtk', '4.0')
gi.require_version('Adw', '1')
from gi.repository import Gtk, Adw, Gio, GLib, Gdk
import subprocess
import os
import re
import shutil
from pathlib import Path
from configparser import ConfigParser

# --- Helper Functions ---

BROWSERS = [
    ('vivaldi-stable', 'Vivaldi'),
    ('vivaldi', 'Vivaldi'),
    ('brave', 'Brave'),
    ('brave-browser', 'Brave'),
    ('chromium', 'Chromium'),
    ('chromium-browser', 'Chromium'),
    ('google-chrome', 'Google Chrome'),
    ('firefox', 'Firefox'),
]

def get_installed_browsers():
    """Return list of (command, display_name) for installed browsers."""
    found = []
    seen_names = set()
    for cmd, name in BROWSERS:
        if shutil.which(cmd) and name not in seen_names:
            found.append((cmd, name))
            seen_names.add(name)
    return found

def get_existing_webapps():
    """Scan ~/.local/share/applications for webapp-*.desktop files."""
    apps_dir = Path.home() / '.local' / 'share' / 'applications'
    webapps = []

    if not apps_dir.exists():
        return webapps

    for desktop_file in sorted(apps_dir.glob('webapp-*.desktop')):
        try:
            config = ConfigParser(interpolation=None)
            config.read(desktop_file)

            if 'Desktop Entry' not in config:
                continue

            entry = config['Desktop Entry']
            name = entry.get('Name', desktop_file.stem)
            icon = entry.get('Icon', 'applications-internet')
            exec_cmd = entry.get('Exec', '')

            # Extract URL from Exec line
            url_match = re.search(r'--app=(https?://[^\s]+)', exec_cmd)
            url = url_match.group(1) if url_match else ''

            # Get slug from filename
            slug = desktop_file.stem.replace('webapp-', '')

            webapps.append({
                'name': name,
                'slug': slug,
                'icon': icon,
                'url': url,
                'desktop_file': str(desktop_file),
            })
        except Exception:
            continue

    return webapps

def delete_webapp(slug):
    """Remove webapp desktop files and data directory."""
    apps_dir = Path.home() / '.local' / 'share' / 'applications'
    desktop_dir = Path.home() / 'Desktop'
    webapps_dir = Path.home() / '.local' / 'share' / 'webapps'

    desktop_file = apps_dir / f'webapp-{slug}.desktop'
    desktop_shortcut = desktop_dir / f'webapp-{slug}.desktop'
    data_dir = webapps_dir / slug

    errors = []

    try:
        if desktop_file.exists():
            desktop_file.unlink()
    except Exception as e:
        errors.append(f"Desktop file: {e}")

    try:
        if desktop_shortcut.exists():
            desktop_shortcut.unlink()
    except Exception as e:
        errors.append(f"Desktop shortcut: {e}")

    try:
        if data_dir.exists():
            shutil.rmtree(data_dir)
    except Exception as e:
        errors.append(f"Data directory: {e}")

    # Update desktop database
    try:
        subprocess.run(
            ['update-desktop-database', str(apps_dir)],
            capture_output=True,
            timeout=5
        )
    except Exception:
        pass

    return len(errors) == 0, errors

def create_webapp(url, name=None, browser=None, isolate=False, wmclass=None):
    """Call webapp-make CLI to create the web app."""
    cmd = ['webapp-make', url]

    if name:
        cmd.extend(['--name', name])
    if browser and browser != 'auto':
        cmd.extend(['--browser', browser])
    if isolate:
        cmd.append('--isolate')
    if wmclass:
        cmd.extend(['--class', wmclass])

    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=30
        )
        output = result.stdout.strip() or result.stderr.strip()
        return result.returncode == 0, output
    except subprocess.TimeoutExpired:
        return False, "Command timed out"
    except Exception as e:
        return False, str(e)

def validate_url(url):
    """Validate and normalize URL. Returns normalized URL or None if invalid."""
    if not url or not url.strip():
        return None

    url = url.strip()

    # Add https:// if no protocol
    if not re.match(r'^[a-zA-Z]+://', url):
        url = 'https://' + url

    # Basic URL validation
    pattern = r'^https?://[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*'
    if re.match(pattern, url):
        return url
    return None

def guess_name_from_url(url):
    """Extract a friendly name from URL domain."""
    if not url:
        return ''

    # Remove protocol
    domain = re.sub(r'^[a-zA-Z]+://', '', url)
    # Remove path
    domain = domain.split('/')[0]
    # Remove port
    domain = domain.split(':')[0]
    # Remove www
    domain = re.sub(r'^www\d*\.', '', domain)
    # Remove common TLDs for cleaner name
    domain = re.sub(r'\.(com|org|net|io|app|dev|ai|co)$', '', domain, flags=re.IGNORECASE)
    # Convert to title case
    words = re.split(r'[-_.]', domain)
    return ' '.join(word.capitalize() for word in words if word)


# --- GTK4/Adwaita Application ---

class CreateDialog(Adw.Dialog):
    """Dialog for creating a new web app."""

    def __init__(self, parent, browsers, on_created_callback):
        super().__init__()
        self.parent_window = parent
        self.browsers = browsers
        self.on_created = on_created_callback

        self.set_title("Create Web App")
        self.set_content_width(450)
        self.set_content_height(400)

        # Main container
        toolbar_view = Adw.ToolbarView()
        self.set_child(toolbar_view)

        # Header bar
        header = Adw.HeaderBar()
        header.set_show_end_title_buttons(False)
        header.set_show_start_title_buttons(False)

        cancel_btn = Gtk.Button(label="Cancel")
        cancel_btn.connect('clicked', lambda _: self.close())
        header.pack_start(cancel_btn)

        self.create_btn = Gtk.Button(label="Create")
        self.create_btn.add_css_class('suggested-action')
        self.create_btn.connect('clicked', self.on_create_clicked)
        self.create_btn.set_sensitive(False)
        header.pack_end(self.create_btn)

        toolbar_view.add_top_bar(header)

        # Content
        scroll = Gtk.ScrolledWindow()
        scroll.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        toolbar_view.set_content(scroll)

        clamp = Adw.Clamp()
        clamp.set_maximum_size(400)
        clamp.set_margin_top(24)
        clamp.set_margin_bottom(24)
        clamp.set_margin_start(12)
        clamp.set_margin_end(12)
        scroll.set_child(clamp)

        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=24)
        clamp.set_child(box)

        # URL group
        url_group = Adw.PreferencesGroup()
        url_group.set_title("Website")
        box.append(url_group)

        # URL entry with paste button
        self.url_row = Adw.EntryRow()
        self.url_row.set_title("URL")
        self.url_row.connect('changed', self.on_url_changed)

        paste_btn = Gtk.Button(icon_name="edit-paste-symbolic")
        paste_btn.set_valign(Gtk.Align.CENTER)
        paste_btn.add_css_class('flat')
        paste_btn.set_tooltip_text("Paste from clipboard")
        paste_btn.connect('clicked', self.on_paste_clicked)
        self.url_row.add_suffix(paste_btn)

        url_group.add(self.url_row)

        # Name entry
        self.name_row = Adw.EntryRow()
        self.name_row.set_title("App Name (optional)")
        url_group.add(self.name_row)

        # Browser group
        browser_group = Adw.PreferencesGroup()
        browser_group.set_title("Browser")
        box.append(browser_group)

        # Browser dropdown
        self.browser_row = Adw.ComboRow()
        self.browser_row.set_title("Browser")

        browser_model = Gtk.StringList()
        browser_model.append("Auto-detect")
        for cmd, name in self.browsers:
            browser_model.append(name)
        self.browser_row.set_model(browser_model)
        self.browser_row.set_selected(0)

        browser_group.add(self.browser_row)

        # Isolated profile switch
        self.isolate_row = Adw.SwitchRow()
        self.isolate_row.set_title("Isolated Profile")
        self.isolate_row.set_subtitle("Create separate browser profile for this app")
        browser_group.add(self.isolate_row)

        # Advanced section
        advanced_group = Adw.PreferencesGroup()
        box.append(advanced_group)

        self.advanced_expander = Adw.ExpanderRow()
        self.advanced_expander.set_title("Advanced")
        advanced_group.add(self.advanced_expander)

        self.wmclass_row = Adw.EntryRow()
        self.wmclass_row.set_title("Window Class")
        self.advanced_expander.add_row(self.wmclass_row)

        # Try to paste URL from clipboard on open
        GLib.idle_add(self.try_clipboard_paste)

    def try_clipboard_paste(self):
        """Try to get URL from clipboard on dialog open."""
        display = Gdk.Display.get_default()
        if not display:
            return False

        clipboard = display.get_clipboard()
        clipboard.read_text_async(None, self.on_clipboard_read)
        return False

    def on_clipboard_read(self, clipboard, result):
        """Handle clipboard read result."""
        try:
            text = clipboard.read_text_finish(result)
            if text and validate_url(text):
                # Only paste if URL field is empty
                if not self.url_row.get_text():
                    self.url_row.set_text(text.strip())
        except Exception:
            pass

    def on_paste_clicked(self, button):
        """Handle paste button click."""
        display = Gdk.Display.get_default()
        if not display:
            return

        clipboard = display.get_clipboard()
        clipboard.read_text_async(None, self.on_paste_clipboard_read)

    def on_paste_clipboard_read(self, clipboard, result):
        """Handle clipboard read for paste button."""
        try:
            text = clipboard.read_text_finish(result)
            if text:
                self.url_row.set_text(text.strip())
        except Exception:
            pass

    def on_url_changed(self, entry):
        """Validate URL and update create button state."""
        url = entry.get_text()
        valid = validate_url(url) is not None
        self.create_btn.set_sensitive(valid)

        if valid:
            entry.remove_css_class('error')
        elif url:
            entry.add_css_class('error')

    def on_create_clicked(self, button):
        """Handle create button click."""
        url = validate_url(self.url_row.get_text())
        if not url:
            return

        name = self.name_row.get_text().strip() or None

        # Get browser
        browser = None
        selected = self.browser_row.get_selected()
        if selected > 0 and selected <= len(self.browsers):
            browser = self.browsers[selected - 1][0]

        isolate = self.isolate_row.get_active()
        wmclass = self.wmclass_row.get_text().strip() or None

        # Disable button during creation
        self.create_btn.set_sensitive(False)
        self.create_btn.set_label("Creating...")

        # Run in thread to avoid blocking UI
        def do_create():
            success, message = create_webapp(url, name, browser, isolate, wmclass)
            GLib.idle_add(self.on_create_finished, success, message)

        import threading
        thread = threading.Thread(target=do_create)
        thread.daemon = True
        thread.start()

    def on_create_finished(self, success, message):
        """Handle creation result."""
        self.create_btn.set_label("Create")
        self.create_btn.set_sensitive(True)

        if success:
            self.on_created(True, message)
            self.close()
        else:
            self.on_created(False, message)


class MainWindow(Adw.ApplicationWindow):
    """Main application window showing web apps list."""

    def __init__(self, app):
        super().__init__(application=app)
        self.app = app

        self.set_title("Web App Manager")
        self.set_default_size(500, 600)

        # Toast overlay for notifications
        self.toast_overlay = Adw.ToastOverlay()
        self.set_content(self.toast_overlay)

        # Main toolbar view
        toolbar_view = Adw.ToolbarView()
        self.toast_overlay.set_child(toolbar_view)

        # Header bar
        header = Adw.HeaderBar()
        toolbar_view.add_top_bar(header)

        # Content
        scroll = Gtk.ScrolledWindow()
        scroll.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        toolbar_view.set_content(scroll)

        clamp = Adw.Clamp()
        clamp.set_maximum_size(600)
        clamp.set_margin_top(24)
        clamp.set_margin_bottom(24)
        clamp.set_margin_start(12)
        clamp.set_margin_end(12)
        scroll.set_child(clamp)

        self.main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=24)
        clamp.set_child(self.main_box)

        # Create button at top
        create_btn = Gtk.Button()
        create_btn.add_css_class('suggested-action')
        create_btn.add_css_class('pill')

        btn_content = Adw.ButtonContent()
        btn_content.set_icon_name("list-add-symbolic")
        btn_content.set_label("Create New Web App")
        create_btn.set_child(btn_content)
        create_btn.connect('clicked', self.on_create_clicked)

        btn_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
        btn_box.set_halign(Gtk.Align.CENTER)
        btn_box.append(create_btn)
        self.main_box.append(btn_box)

        # Web apps list
        self.apps_group = Adw.PreferencesGroup()
        self.main_box.append(self.apps_group)

        # Load web apps
        self.refresh_apps_list()

    def refresh_apps_list(self):
        """Reload the web apps list."""
        # Clear existing rows
        while True:
            row = self.apps_group.get_first_child()
            if row is None:
                break
            # Skip the group title/header
            if isinstance(row, Adw.ActionRow):
                self.apps_group.remove(row)
            else:
                break

        # Actually clear all children properly
        # PreferencesGroup doesn't have a simple clear method
        # We need to recreate it
        self.main_box.remove(self.apps_group)
        self.apps_group = Adw.PreferencesGroup()
        self.main_box.append(self.apps_group)

        webapps = get_existing_webapps()

        if webapps:
            self.apps_group.set_title(f"Your Web Apps ({len(webapps)})")

            for webapp in webapps:
                row = Adw.ActionRow()
                row.set_title(webapp['name'])
                row.set_subtitle(webapp['url'][:50] + '...' if len(webapp.get('url', '')) > 50 else webapp.get('url', ''))

                # Try to load icon
                icon_path = webapp.get('icon', '')
                if icon_path and os.path.isfile(icon_path):
                    try:
                        icon = Gtk.Image.new_from_file(icon_path)
                        icon.set_pixel_size(32)
                        row.add_prefix(icon)
                    except Exception:
                        icon = Gtk.Image.new_from_icon_name("applications-internet")
                        icon.set_pixel_size(32)
                        row.add_prefix(icon)
                else:
                    icon = Gtk.Image.new_from_icon_name("applications-internet")
                    icon.set_pixel_size(32)
                    row.add_prefix(icon)

                # Delete button
                delete_btn = Gtk.Button(icon_name="user-trash-symbolic")
                delete_btn.set_valign(Gtk.Align.CENTER)
                delete_btn.add_css_class('flat')
                delete_btn.add_css_class('error')
                delete_btn.set_tooltip_text("Delete web app")
                delete_btn.connect('clicked', self.on_delete_clicked, webapp)
                row.add_suffix(delete_btn)

                # Chevron
                chevron = Gtk.Image.new_from_icon_name("go-next-symbolic")
                chevron.add_css_class('dim-label')
                row.add_suffix(chevron)
                row.set_activatable(True)
                row.connect('activated', self.on_app_activated, webapp)

                self.apps_group.add(row)
        else:
            self.apps_group.set_title("No Web Apps")
            self.apps_group.set_description("Click the button above to create your first web app")

    def on_create_clicked(self, button):
        """Show create dialog."""
        browsers = get_installed_browsers()
        dialog = CreateDialog(self, browsers, self.on_webapp_created)
        dialog.present(self)

    def on_webapp_created(self, success, message):
        """Handle webapp creation result."""
        if success:
            self.show_toast("Web app created successfully")
            self.refresh_apps_list()
        else:
            self.show_toast(f"Failed to create: {message}")

    def on_delete_clicked(self, button, webapp):
        """Show delete confirmation dialog."""
        dialog = Adw.AlertDialog()
        dialog.set_heading(f"Delete {webapp['name']}?")
        dialog.set_body("This will remove the web app shortcut and its data. This cannot be undone.")
        dialog.add_response("cancel", "Cancel")
        dialog.add_response("delete", "Delete")
        dialog.set_response_appearance("delete", Adw.ResponseAppearance.DESTRUCTIVE)
        dialog.set_default_response("cancel")
        dialog.set_close_response("cancel")
        dialog.connect('response', self.on_delete_response, webapp)
        dialog.present(self)

    def on_delete_response(self, dialog, response, webapp):
        """Handle delete confirmation response."""
        if response == "delete":
            success, errors = delete_webapp(webapp['slug'])
            if success:
                self.show_toast(f"Deleted {webapp['name']}")
                self.refresh_apps_list()
            else:
                self.show_toast(f"Error deleting: {', '.join(errors)}")

    def on_app_activated(self, row, webapp):
        """Launch the web app when row is activated."""
        desktop_file = webapp.get('desktop_file')
        if desktop_file and os.path.isfile(desktop_file):
            try:
                # Try gtk-launch first
                app_id = os.path.basename(desktop_file).replace('.desktop', '')
                subprocess.Popen(['gtk-launch', app_id],
                               stdout=subprocess.DEVNULL,
                               stderr=subprocess.DEVNULL)
            except Exception:
                pass

    def show_toast(self, message):
        """Show a toast notification."""
        toast = Adw.Toast(title=message)
        toast.set_timeout(3)
        self.toast_overlay.add_toast(toast)


class WebAppManagerApp(Adw.Application):
    """Main application class."""

    def __init__(self):
        super().__init__(
            application_id='com.github.webapp-make-gui',
            flags=Gio.ApplicationFlags.FLAGS_NONE
        )

    def do_startup(self):
        """Called when the application starts."""
        Adw.Application.do_startup(self)
        # Use system color scheme preference
        style_manager = Adw.StyleManager.get_default()
        style_manager.set_color_scheme(Adw.ColorScheme.PREFER_DARK)

    def do_activate(self):
        """Called when the application is activated."""
        win = self.props.active_window
        if not win:
            win = MainWindow(self)
        win.present()


def main():
    """Application entry point."""
    app = WebAppManagerApp()
    return app.run(None)


if __name__ == '__main__':
    main()
